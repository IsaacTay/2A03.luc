module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    .rst(rst) {
        counter slow_clock(#SIZE(1), #DIV(24));
    }
  }
  
  sig clk2; 
  .clk(clk2) {
    dff pc[16], sp[8], a[8], x[8], y[8], register[8], t1[2], t2, oc[16];
  }
  
  .rclk(clk2), .wclk(clk2) {
    simple_dual_ram ram(#DEPTH(h10000));
  }
  
  const ROM = $reverse({
    ha9, h05, h85, h01, ha9, h06, h25, h01,
    ha9, h05, h85, h01, ha9, h06, h25, h01,
    ha9, h05, h85, h01, ha9, h06, h25, h01,
    ha9, h05, h85, h01, ha9, h06, h25, h01,
    ha9, h05, h85, h01, ha9, h06, h25, h01
  });
  
  const OPCODES = $reverse({
b0000000000000000001,
b0111100110000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0111100010000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0111100000000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0111100010000000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0111101000100000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0111100011000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0111100010100000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0111100011000000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110000110000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110000010000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110000000000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110000010000000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110001000100000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110000011000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110000010100000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110000011000000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0101100110000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0101100010000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0101100000000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0101100010000000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0101101000100000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0101100011000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0101100010100000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0101100011000000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000000110000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000000010000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000000000000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000000010000000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000001000100000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000000011000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000000010100000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000000011000000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100110000001101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100010000001101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100000000001101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100010000001110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110101000100001101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100011000001101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100010100001110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100011000001110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100110001000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100010001000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100000001000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100010001000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110101000101000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100011001000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100010101000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100011001000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100110000000001,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100010000000001,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100000000000001,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100010000000010,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110101000100000001,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100011000000001,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100010100000010,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0110100011000000010,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000010110000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000010010000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000010000000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000010010000000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000011000100000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000010011000000101,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000010010100000110,
b0000000000000000001,
b0000000000000000001,
b0000000000000000001,
b0000010011000000110,
b0000000000000000001,
b0000000000000000001
 });
  
  sig opcode[23];
  sig rdata[8], mdata[8], maddr[16], data_ready;
  sig alufn[6], post_index, lookup, data, xsel, ysel, asel[2], bsel[1], wsel[2], we, l[2];
  sig buffer[16];
  
  alu alu(#BITS(8));
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    usb_tx = usb_rx;        // loop serial port
    
    led = 8h00;             // turn LEDs off
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    // Disable ram by default
    ram.raddr = 0;
    ram.write_en = 0;
    ram.waddr = 0;
    ram.write_data = 0;
    
    // ALU Defaults
    alu.a = 0;
    alu.b = 0;
    alu.alufn = 0;
    
    opcode = OPCODES[ROM[pc.q]];
    rdata  = ROM[oc.q];
    
    // START: opcode convience assignments
    l = opcode[1:0];
    we = opcode[2];
    wsel = opcode[4:3];
    bsel = opcode[5:5];
    asel = opcode[7:6];
    ysel = opcode[8];
    xsel = opcode[9];
    data = opcode[10];
    lookup = opcode[11];
    post_index = opcode[12];
    alufn = opcode[18:13];
    // END: opcode convience assignments
    
    buffer = 0;
    data_ready = 0;
    if (t1.q == b01) {
      buffer = rdata;
      register.d = buffer[7:0];
    } else if (t1.q == b10) {
      buffer = c{rdata, register.q};
    }
    if (t1.q == l) {
      mdata = 0;
      if (t2.q == 0) {
        maddr = hffff;
        if (data) {
          maddr = buffer;
          if (lookup) {
            case (c{post_index, xsel, ysel}) {
              b001: maddr = c{ROM[buffer+y.q+1], ROM[buffer+y.q]};
              b010: maddr = c{ROM[buffer+x.q+1], ROM[buffer+x.q]};
              b101: maddr = c{ROM[buffer+1], ROM[buffer]} + y.q;
              b110: maddr = c{ROM[buffer+1], ROM[buffer]} + x.q;
              default: maddr = c{ROM[buffer+1], ROM[buffer]};
            }
          } else {
            if (xsel) {
              maddr = buffer + x.q;
            } else if (ysel)  {
              maddr = buffer + y.q;
            }
          }
          ram.raddr  = maddr;
          t2.d = 1;
        } else {
          mdata = buffer[7:0]; // Immediate
          if (lookup) { // Indirect
            mdata = c{ROM[buffer+1], ROM[buffer]};
          }
          data_ready = 1;
        }
      } else if (t2.q == 1) {
        mdata = ram.read_data;
        if (post_index) {
          if (xsel) {
            mdata = ram.read_data + x.q;
          } else if (ysel) {
            mdata = ram.read_data + y.q;
          }
        }
        data_ready = 1;
      }
      if (data_ready) {
        case (asel) {
          b0: alu.a = a.q;
          b1: alu.a = mdata;
        }
        case (bsel) {
          b0: alu.b = mdata;
        }
        alu.alufn = alufn;
        if (we) {
          case (wsel) {
            b00: a.d = alu.alu;
            b01:
              ram.waddr = maddr;
              ram.write_en = 1;
              ram.write_data = alu.alu;
            b01: x.d = alu.alu;
            b11: y.d = alu.alu;
          }
        }
        
        t2.d = 0;
        t1.d = 0;
      }
    } else {
      oc.d = oc.q + 1;
      t1.d = t1.q + 1;
    }
    if (t1.q == 0) {
      opcode = OPCODES[ROM[oc.q]];
      pc.d = oc.q;
      
      t1.d = 1;
      t2.d = 0;
      register.d = 0;
      
      // 1 byte instructions
    }
    
    // DEBUG
    clk2 = slow_clock.value;
    //clk2 = clk;
    io_led[0] = oc.q;
    io_led[1] = a.q;
    io_led[2] = rdata;
  }
}